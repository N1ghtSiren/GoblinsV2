---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Siren.
--- DateTime: 24.10.2022 10:30
---

---@class gunitData
---@field unit unit
---@field hero_class integer
---@field base_as_cd number
---@field base_ms number
---@field stats stats
---@field equipped_item_slots table
---@field equipped_items      table
---@field events unitevents

---@type gunitData
local template_gunitData =
{
  unit = nil,
  hero_class = constants.hero_class.none,
  base_as_cd = 1,
  base_ms = 350,
  stats = nil,
  equipped_item_slots = {
    [constants.item_slots.none] = 0,
    [constants.item_slots.weapon] = 0,
    [constants.item_slots.armour] = 0,
    [constants.item_slots.full_set] = 0,
    [constants.item_slots.accessory] = 0,
  },
  equipped_items = {},
  events = events.GetUnitEventsTemplate(),
}

--[[
view

alloc
init
create
validate
delete
]]

--------------------------------------------------------------------
-- private logic
--------------------------------------------------------------------

local branch = storage.CreateNewBranch(storage.branch_ids.gunit)

privateDataRequest.register.gunit(branch)

--------------------------------------------------------------------

---@param gunitData gunitData
local function InitView(gunitData)
  local unit = gunitData.unit

  -- 9 damage with 1 dice, 1 side will look like 10~10
  SetUnitDamageDicesByIndex(unit, 0, 1)
  SetUnitDamageDicesSideByIndex(unit, 0, 1)
end


---@param gunitData gunitData
local function UpdateView(gunitData)
  local unit, stats, as_percent, as_cd

  unit = gunitData.unit
  stats = gunitData.stats

  SetHeroStr(unit, R2I(stats.str), true)
  SetHeroAgi(unit, R2I(stats.agi), true)
  SetHeroInt(unit, R2I(stats.int), true)

  SetUnitMaxLife(unit, R2I(stats.max_life))
  SetUnitMaxMana(unit, R2I(stats.max_mana))
  SetUnitLifeRegen(unit, stats.hp_regen)
  SetUnitManaRegen(unit, stats.mp_regen)

  SetUnitArmour(unit, R2I(stats.armour))

  SetUnitMoveSpeed(unit, R2I(gunitData.base_ms))

  --if its using damage
  if(stats.damage ~= 0)then
    SetUnitBaseDamageByIndex(unit, 0, R2I(stats.damage) - 1)
  end

  --if its using dps
  if(stats.dps ~= 0)then
    local attacks_per_sec = 1/gunitData.base_as_cd
    local dmg = stats.dps / attacks_per_sec
    SetUnitBaseDamageByIndex(unit, 0, R2I(dmg) - 1)
  end

  --if it uses both - that's error
  if(stats.damage ~= 0 and stats.dps ~= 0)then
    local str = "warning: Unit uses both damage and dps calculations!\n unit: %s; id: %s"

    messages.Send(messages.levels.game_error, str, GetUnitName(unit), fourci(GetUnitTypeId(unit)))
  end

  as_percent = math.clamp(stats.attackspeed, constants.min_attack_speed, constants.max_attack_speed) * 0.01
  as_cd = gunitData.base_as_cd / (1 + as_percent)
  SetUnitAttackCooldownByIndex(unit, 0, as_cd)
end


---@param gunitData gunitData
local function DeleteView(gunitData)
  RemoveUnit(gunitData.unit)
end


---@param unit unit
---@param abil_list table
local function InitAbilities(unit, abil_list)
  for _, id in pairs(abil_list)do
    gability.Add(unit, id)
  end
end

--------------------------------------------------------------------

---@return gunitData
local function GetTemplate()
  return table.deepCopy(template_gunitData)
end


---@param unit unit
---@return gunitData
local function Alloc(unit)
  local gunitData = GetTemplate()
  gunitData.unit = unit

  branch:set(unit, gunitData)

  return gunitData
end


---@param gunitData gunitData
local function Init(gunitData)
  local unitid, dbEntry

  unitid = GetUnitTypeId(gunitData.unit)
  dbEntry = database.units.Read(unitid)
  --move needed data
  gunitData.hero_class = dbEntry.hero_class
  gunitData.stats = table.deepCopy(dbEntry.stats)
  gunitData.base_as_cd = dbEntry.base_as_cd
  gunitData.base_ms = dbEntry.base_ms

  InitAbilities(gunitData.unit, dbEntry.abil_list)

  InitView(gunitData)
  UpdateView(gunitData)
end


---@param owning_player_pid integer
---@param x number
---@param y number
---@return unit
local function Create(owning_player_pid, unitid, x, y)
  local unit, gunitData

  unit = CreateUnit(Player(owning_player_pid), fourcc(unitid), x, y, 0)
  gunitData = Alloc(unit)
  Init(gunitData)

  return unit
end

---@param unit unit
local function Validate(unit)
  local gunitData

  if(branch:exists(unit) == false)then
    gunitData = Alloc(unit)
    Init(gunitData)
  end

end

---@param unit unit
local function Delete(unit)
  for i = 0, 5 do
    local item = UnitItemInSlot(unit, i)
    if(item ~= nil)then
      gitem.Delete(item)
    end
  end

  DeleteView(branch:get(unit))
  branch:free(unit)
end

--------------------------------------------------------------------

---@param gunitData gunitData
---@param gitemData gitemData
local function EquipItem(gunitData, gitemData)
  stats.sum(gunitData.stats, gitemData.stats)

  --modify this unit gitem slots
  gunitData.equipped_item_slots[gitemData.slot] = gunitData.equipped_item_slots[gitemData.slot] + 1
  table.insert(gunitData.equipped_items, gitemData.item)

  --fire events
  UpdateView(gunitData)
end

local IsItemEquipableBy = {

  SlotLimit = function(gunitData, gitemData)
    local can_equip = gunitData.equipped_item_slots[gitemData.slot] < constants.max_permanent_item_count[gitemData.slot]

    local pid = GetPlayerId(GetOwningPlayer(gunitData.unit))

    if(can_equip == false)then
      gitem.ShowError.SlotLimit(pid, gitemData.slot)
    end

    return can_equip
  end,


  HeroRestriction = function(gunitData, gitemData)
    local can_equip = gitemData.hero_class == constants.hero_class.none or gitemData.hero_class == gunitData.hero_class

    local pid = GetPlayerId(GetOwningPlayer(gunitData.unit))

    if(can_equip == false)then
      gitem.ShowError.HeroRestriction(pid, gitemData.hero_class)
    end

    return can_equip
  end,

  SingleItem = function(gunitData, gitemData)
    if(gitemData.is_single == false)then return true end

    local can_equip = true

    for _, v in pairs(gunitData.equipped_items)do
      if(GetItemTypeId(v) == GetItemTypeId(gitemData.item))then
        can_equip = false
        break;
      end
    end

    local pid = GetPlayerId(GetOwningPlayer(gunitData.unit))

    if(can_equip == false)then
      gitem.ShowError.SingleItem(pid)
    end

    return can_equip
  end
}

---@param unit unit
---@param item item
local function TryEquipItem(unit, item)
  local gunitData, gitemData

  --Validate(unit)
  gitem.Validate(item)

  gunitData = branch:get(unit)
  gitemData = privateDataRequest.gitemData(item)

  -- item without db entry, may happen
  if(gitemData.isNonInitialized)then return end
  -- non-permanent items cannot have stats
  if(gitemData.type ~= constants.item_types.permanent)then return end

  local equipable_by_slot_limit, equipable_by_hero_restriction, equipable_by_single_item

  equipable_by_slot_limit = IsItemEquipableBy.SlotLimit(gunitData, gitemData)
  equipable_by_hero_restriction = IsItemEquipableBy.HeroRestriction(gunitData, gitemData)
  equipable_by_single_item = IsItemEquipableBy.SingleItem(gunitData, gitemData)

  if(equipable_by_slot_limit and equipable_by_hero_restriction and equipable_by_single_item)then
    EquipItem(gunitData, gitemData)
    events.invoke.item.onEquip(unit, item)
  else
    SetItemPosition(item, GetItemX(item), GetItemY(item))
    --drop trig triggers instantly
  end

end

---@param gunitData gunitData
---@param gitemData gitemData
local function DropItemFinally(gunitData, gitemData)
  stats.sub(gunitData.stats, gitemData.stats)

  --modify this unit gitem slots
  gunitData.equipped_item_slots[gitemData.slot] = gunitData.equipped_item_slots[gitemData.slot] - 1
  table.removeValue(gunitData.equipped_items, gitemData.item)

  --fire events
  UpdateView(gunitData)
end


---@param unit unit
---@param item item
local function DropItem(unit, item)
  local gunitData, gitemData

  gunitData = branch:get(unit)
  gitemData = privateDataRequest.gitemData(item)

  -- if magic will happen, and it syka will happen
  if(gunitData == nil or gitemData == nil)then return end

  --ignore non-custom items, may happen
  if(gitemData.isNonInitialized)then return end

  if(table.contains(gunitData.equipped_items, gitemData.item))then
    DropItemFinally(gunitData, gitemData)
    events.invoke.item.onDrop(unit, item)
  end

end

--------------------------------------------------------------------
-- public functions
--------------------------------------------------------------------

gunit = {
  Create = Create,
  Delete = Delete,
  Validate = Validate,
  EquipItem = TryEquipItem,
  DropItem = DropItem,
}